#pragma config(Sensor, S1,     Bumper1,	sensorTouch)
#pragma config(Sensor, S2,     MSIMU,   sensorI2CCustomFastSkipStates)
#pragma config(Sensor, S4,     XBee,    sensorHighSpeed)
#pragma config(Motor,  motorA, M1,      tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC, M2,      tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")

#include "drivers/mindsensors-imu.h"

/* notes
57600
xbee on PC source addr 4 dest 3
xbee on nxt source 3 dest 4

1 touch
2 Mindsensor Absolute IMU
4 xbee (485)

A M1 driveRight
C M2 driveLeft

*/

#define WDS writeDebugStream

float PI2 = 2.0 * PI;

float WheelBase = 120.0;
float WheelDiameter = 80.0;
int TicksPerRevolution = 360;
float ticksToMM;		// calculated, this is what we need.

long CurrentLeftTacho = 0;
long CurrentRightTacho = 0;
long LastLeftTacho = 0;
long LastRightTacho = 0;

float RobotX = 0;
float RobotY = 0;
float RobotH = 0;

int hsInBuffIdx = 0;
ubyte hsInBuff[128];
char txt[64]; // for debug print (not thread safe!)
char json[64];	// (not thread safe!)

//---  Util  -------------------------

float NormalizeAngle(float angle)
{
	while (angle > PI2)
		angle -= PI2;
	while (angle < -PI2)
		angle += PI2;
	return angle;
}

float GetGyroRateZ()
{
	//Sensitivity Level Reading Units
	//250 degrees/sec 8.75 milli-degrees/second
	//500 degrees/second 17.5 milli-degrees/second
	//2000 degrees/second 70 milli-degrees/second

	int x, y, z;
	MSIMUreadGyroAxes(MSIMU, x, y, z);
	return z * 8.75 / 1000.0;		// for default sensitivty
}

float meanGyroZValue(int interval, int N)
{
	float som = 0;
	for(int i = 0; i < N; i++)
	{
		som += GetGyroRateZ();
		wait1Msec(interval);
	}
	return som / N;
}

float ToDegrees(float a)
{
	return a * 180 / PI;
}

float ToRadians(float a)
{
	return a * PI / 180.0;
}

void WaitMotorsIdle()
{
	while (nMotorRunState[M1] != runStateIdle && nMotorRunState[M1] != runStateIdle)
		wait1Msec(20);
}

float Distance(float x1, float y1, float x2, float y2)
{
	return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
}

//---  incoming subscriptions  -------------------------

task CheckMQTT()
{
	while (true)
	{
		while (nxtGetAvailHSBytes() > 0)
		{
			nxtReadRawHS(&hsInBuff[hsInBuffIdx], 1);
			if (hsInBuff[hsInBuffIdx] == '\n')
			{
				// +++ process
				// +++ shift remaining bytes in buffer if any
				hsInBuffIdx = 0;
				continue;
			}
			hsInBuffIdx++;
			releaseCPU();
		}
		wait1Msec(1000/10);
	}
}

//---  Pose / Kalman  -------------------------

float GyroOffset,
varianceTacho = 0.9,
varianceGyro = 0.119,
varianceFilterPredicted,
varianceFilterUpdated,
kalmanGain,
tachoMeasured,
tachoPredicted,
tachoUpdated,
gyroMeasured;

long lastPoseTime = time1[T1];
void CalcPoseGyro()
{
	// milli-degree/second is what the gyro uses
	// time1 uses milliseconds
	long nowTime = time1[T1];
	float dt = (nowTime - lastPoseTime) / 1000.0;		// milli-degree/second is what the gyro reports

	CurrentLeftTacho = nMotorEncoder[M2];
	CurrentRightTacho = nMotorEncoder[M1];

	long leftTachoChange = CurrentLeftTacho - LastLeftTacho;
	long rightTachoChange = CurrentRightTacho - LastRightTacho;

	if (abs(leftTachoChange) + abs(rightTachoChange) < 1)
		return; // insignificant movement, avoid updating

	float delta = (leftTachoChange + rightTachoChange) * ticksToMM / 2.0;
	tachoMeasured = (leftTachoChange - rightTachoChange) * ticksToMM / WheelBase;
	gyroMeasured = meanGyroZValue(5,4) - GyroOffset;

	// predict
	tachoPredicted = tachoUpdated + dt * gyroMeasured;
	varianceFilterPredicted = varianceFilterUpdated + varianceGyro;

	// heading must be between 0 and 2*PI
	tachoPredicted = NormalizeAngle(tachoPredicted);

	// Kalman gain
	kalmanGain = varianceFilterPredicted / (varianceFilterPredicted + varianceTacho);

	// update
	tachoUpdated = tachoPredicted + kalmanGain * (tachoMeasured - tachoPredicted);
	varianceFilterUpdated = varianceFilterPredicted + kalmanGain * (varianceTacho - varianceFilterPredicted);

	RobotH = NormalizeAngle(tachoUpdated);

	// +++ question? the original is based on using an average of what we started with vs where we ended
	// the latter is based on where we ended
	// niether really consider snaking - ie the distance traveled doesnt reflect actual distance
	//RobotX += delta * sin(RobotH + (tachoAlpha / 2.0));
	//RobotY += delta * -cos(RobotH + (tachoAlpha / 2.0));

	RobotX += delta * sin(RobotH);
	RobotY += delta * -cos(RobotH);

	LastLeftTacho = CurrentLeftTacho;
	LastRightTacho = CurrentRightTacho;

	sprintf(json, "PUBnxt/Pose,{\"x\":%f,\"y\":%f,\"h\":%f}\n", RobotX, RobotY, RobotH);
	//WDS(txt);
	nxtWriteRawHS(json, strlen(json), 0);

	lastPoseTime = nowTime;
}

task UpdatePose()
{
	while (true)
	{
		CalcPoseGyro();
		wait1Msec(1000 / 20); // times per second to update
	}
}

//--- PID -------------------

float K_P = 20.0, K_I = 0.0, K_D = 5.0;

float pidPreviousError = 0;
float pidIntegral, derivative;	// global so we can debug

float GetPidTurnPower(float sp, float dt)
{
	float error = sp - RobotH;
	pidIntegral = pidIntegral + error * dt;
	derivative = (error - pidPreviousError) / dt;
	float p = K_P * error + K_I * pidIntegral + K_D * derivative;
p = p > 100 ? 100 : p < -100 ? -100 : p;
	pidPreviousError = error;
	return p;
}

//void PidRotate(float angle)
//{
//	+++ we need to pick base on left or right
//	but -100 is always turn in place, motor power needs to be influenced by direction
//	nSyncedTurnRatio = -100;	// rotate in place

//	char txt[128];
//	long lastTime = time1[T1];
//	nSyncedTurnRatio = -100;	// rotate in place
//	angle = NormalizeAngle(RobotH + angle);
//	sprintf(txt, "Pid Rotate sp(%f) pv(%f)\n", ToDegrees(angle), ToDegrees(RobotH));
//	WDS(txt);
//	while (abs(pidPreviousError) > ToRadians(2))
//	{
//		long timeNow = time1[T1];
//		float dt = (timeNow - lastTime) / 1000.0;
//		float p = GetPidTurnPower(angle, dt);
//		motor[M1] = (int)p;
//		lastTime = timeNow;
//		sprintf(txt, "PidRot sp(%f) pv(%f) error(%f) dt(%f) pwr(%f)\n",
//		ToDegrees(angle), ToDegrees(RobotH), pidPreviousError, dt, p);
//		WDS(txt);
//		wait1Msec(20);
//	}
//	motor[M1] = 0;
//	WaitMotorsIdle();
//	sprintf(txt, "Rotate complete sp(%f) pv(%f)\n", ToDegrees(angle), ToDegrees(RobotH));
//	WDS(txt);
//}

void PidMove(float distance)
{
	float initialH = RobotH;
	long lastTime = time1[T1];
	bool there = false;

	// where we are going
	float goalX = RobotX + distance * -sin(RobotH);	// you really have to watch out, robot vs view x/y
	float goalY = RobotY - distance * cos(RobotH);

	sprintf(txt, "goal: %f, %f\n", goalX, goalY);
	WDS(txt);

	while (!there)
	{
		float distanceToGoal = sqrt((goalX - RobotX ) * (goalX - RobotX ) + (goalY - RobotY) * (goalY - RobotY));
		sprintf(txt, "Distance to goal: %f\n", distanceToGoal);
		WDS(txt);
		sprintf(txt, "pose: %f, %f\n", RobotX, RobotY);
		WDS(txt);

		if (distanceToGoal < 25.0)
		{
			there = true;
			break;
		}
		long nowTime = time1[T1];
		float dt = (nowTime - lastTime) / 1000.0;
		int p = (int)GetPidTurnPower(initialH, dt);
		motor[M2] = 30 + p;
		motor[M1] = 30;
		lastTime = nowTime;
		wait1Msec(1000/20);
	}
	motor[M1] = 0;
	motor[M2] = 0;
	WaitMotorsIdle();
}

//--- main -------------------------

task main()
{
	clearDebugStream();
	WDS("xbee_kalman1.c\n");

	// geometry
	ticksToMM = PI * WheelDiameter / TicksPerRevolution;

	//nSyncedMotors = synchAC; //frankly, worthless in v4.27
	nMotorPIDSpeedCtrl[M1] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[M2] = mtrSpeedReg;

	// connection to MQTT Bridge
	nxtEnableHSPort();
	nxtSetHSBaudRate(57600);
	nxtHS_Mode = hsRawMode;

	// subscribe isnt really being used ATM, but it shows up on
	// the bridge console indicating the connection is good
	string sub = "SUBpc/#\n";
	nxtWriteRawHS(sub, strlen(sub), 0);

	MSIMUsetGyroFilter(MSIMU, MSIMU_GYRO_FILTER_LEVEL_4); // filtering
	wait1Msec(250);		// allow time for reconfigure

	GyroOffset = meanGyroZValue(5,100);
	WDS("GyroOffset %f\n", GyroOffset);

	// initialise the kalman filter;
	tachoUpdated = GetGyroRateZ();
	varianceFilterUpdated = 0;

	time1[T1] = 0;			// resest the clock
	startTask(CheckMQTT);
	startTask(UpdatePose);

	// make a move
	PidMove(2000.0);		// in mm

	//PidRotate(ToRadians(180));
	//PidMove(2000.0);
	//PidRotate(ToRadians(180));

	WDS("Done\n");
	wait1Msec(100);
	stopAllTasks();
}
