#pragma config(Sensor, S1,     Bumper1,	sensorTouch)
#pragma config(Sensor, S2,     MSIMU,   sensorI2CCustomFastSkipStates)
#pragma config(Sensor, S4,     XBee,    sensorHighSpeed)
#pragma config(Motor,  motorA, M1,      tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC, M2,      tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")
#include "drivers/mindsensors-imu.h"

/* notes
57600
xbee on PC source addr 4 dest 3
xbee on nxt source 3 dest 4

1 touch
2 Mindsensor Absolute IMU
4 xbee (485)

A M1 driveRight
C M2 driveLeft

*/
#define WDS writeDebugStream

float WheelBase = 120.0;
float WheelDiameter = 80.0;
int TicksPerRevolution = 360;
long CurrentLeftTacho = 0;
long CurrentRightTacho = 0;
long LastLeftTacho = 0;
long LastRightTacho = 0;
float RobotX = 0;
float RobotY = 0;
float RobotH = 0;

int hsInBuffIdx = 0;
ubyte hsInBuff[128];
char txt[128];	// for debug strings
char json[128];	// for debug strings

void CheckQ()
{
	while (nxtGetAvailHSBytes() > 0)
	{
		nxtReadRawHS(&hsInBuff[hsInBuffIdx], 1);
		if (hsInBuff[hsInBuffIdx] == '\n')
		{
			// +++ process
			hsInBuffIdx = 0;
		}
		hsInBuffIdx++;
	}
	releaseCPU();
}
float NormalizeAngle(float angle)
{
	while (angle > 2 * PI)
		angle -= (2 * PI);
	while (angle < -2 * PI)
		angle += (2 * PI);
	return angle;
}

/*
void getheading()
{
writeDebugStreamLine("*getheading");
float var_compass  =  0.9,
var_gyro = 0.119,
var_filter_predicted,
var_filter_updated,
kalman_gain,
compass_measured,
compass_predicted,
compass_updated,
gyro_measured,
time_span,
offset;

long time_start, time_end;

bool disturbed;

// get the gyro offset
offset = meanGyroZValue(5,100);
writeDebugStreamLine("gyr offs %f", offset);

// initialise the filter;
compass_updated = SensorValue[COMPASS];
var_filter_updated = 0;

// Run the filter forever;
while (true)
{
// get time span;
time_end = nPgmTime;
time_span = ((float)(time_end - time_start)) / 1000.0;
if (time_span <= 0) {
time_span = 0.02; // this is to compensate for wrapping around the nPgmtime variable;
writeDebugStreamLine("time span wrap");
}
time_start = nPgmTime;

// get measurements from sensors
// (when changing the sample size of the gyro, one must also change the variance)
compass_measured = (float)SensorValue[COMPASS];
gyro_measured = MOUNTING ( meanGyroZValue(5,4) - offset);

// predict;
compass_predicted = compass_updated + time_span * gyro_measured;
var_filter_predicted = var_filter_updated + var_gyro;

// heading must be between 0 and 359
if (compass_predicted < 0)
compass_predicted += 360;
if (compass_predicted >= 360)
compass_predicted -= 360;

// Detect _compass disturbance;
if (abs(compass_predicted - compass_measured) > 2 * sqrt(var_filter_predicted))
disturbed = true;
else
disturbed = false;

// get Kalman gain;
if (disturbed)
kalman_gain = 0;
else
kalman_gain = var_filter_predicted / (var_filter_predicted + var_compass);

// update;
compass_updated = compass_predicted + kalman_gain * (compass_measured - compass_predicted);
var_filter_updated = var_filter_predicted + kalman_gain * (var_compass - var_filter_predicted);

// make result available gobally
heading = compass_updated;

// wait for next iteration;
wait1Msec(0);
}
}
*/

long lastPoseTick;
void UpdatePose()
{
	int x, y, z;

	long nowTime = time1[T1];
	float deltaTime = (nowTime - lastPoseTick) / 1000.0;

	MSIMUreadGyroAxes(MSIMU, x, y, z);

	//sprintf(json, "PUBnxt/Gyro,{\"x\":%d,\"y\":%d,\"z\":%d}\n", x, y, z);
	//nxtWriteRawHS(json, strlen(json), 0);
	//wait1Msec(5);
	//WDS(json);

	float ticksToMM = WheelDiameter / TicksPerRevolution;

	long leftTachoChange = nMotorEncoder[M2] - LastLeftTacho;
	long rightTachoChange = nMotorEncoder[M1] - LastRightTacho;

	if (abs(leftTachoChange) + abs(rightTachoChange) < 1)
		return; // insignificant movement, avoid updating

	if (leftTachoChange - rightTachoChange == 0) // straight
	{
		float leftDelta = leftTachoChange * ticksToMM;
		RobotX += leftDelta * sin(RobotH);
		RobotY += leftDelta * -cos(RobotH);
	}
	else
	{
		float delta = (leftTachoChange + rightTachoChange) * ticksToMM / 2.0;
		float tachoAlpha = (leftTachoChange - rightTachoChange) * ticksToMM / WheelBase;

		//Sensitivity Level Reading Units
		//250 degrees/sec 8.75 milli-degrees/second
		//500 degrees/second 17.5 milli-degrees/second
		//2000 degrees/second 70 milli-degrees/second

		float gyroAlpha = z * 8.75 / 1000.0;

		RobotX += delta * sin(RobotH + (tachoAlpha / 2.0));
		RobotY += delta * -cos(RobotH + (tachoAlpha / 2.0));

		RobotH += tachoAlpha;
		RobotH = NormalizeAngle(RobotH);
	}

	LastLeftTacho = CurrentLeftTacho;
	LastRightTacho = CurrentRightTacho;

	sprintf(json, "PUBnxt/Pose,{\"x\":%f,\"y\":%f,\"h\":%f}\n", RobotX, RobotY, RobotH);
	nxtWriteRawHS(json, strlen(json), 0);

	wait1Msec(1000 / 20);
}

task BgUpdateTask()
{
	while (true)
	{
		//CheckQ();
		UpdatePose();
		wait1Msec(1000 / 20); // times per second to update
	}
}

float ToDegrees(float a)
{
	return a * 180 / PI;
}

float ToRadians(float a)
{
	return a * PI / 180.0;
}

void WaitMotorsIdle()
{
	while (nMotorRunState[M1] != runStateIdle && nMotorRunState[M1] != runStateIdle)
		wait1Msec(20);
}

float K_P = 20.0, K_I = 0, K_D = 5;

float pidPreviousError = 0;
float pidIntegral, derivative;	// global so we can debug

float GetPidTurnPower(float sp, float dt)
{
	float error = sp - RobotH;
	pidIntegral = pidIntegral + error * dt;
	derivative = (error - pidPreviousError) / dt;
	float output = (K_P * error) + (K_I * pidIntegral) + (K_D * derivative);
output = output > 100 ? 100 : output < -100 ? -100 : output;
	pidPreviousError = error;
	return output;
}

void PidMove(float distance)
{
	float initialH = RobotH;
	long lastTime = time1[T1];
	bool there = false;

	// where we are going
	float goalX = RobotX + distance * -sin(RobotH);	// you really have to watch out, robot vs view x/y
	float goalY = RobotY - distance * cos(RobotH);

	sprintf(txt, "goal: %f, %f\n", goalX, goalY);
	WDS(txt);

	while (!there)
	{
		float distanceToGoal = sqrt((goalX - RobotX ) * (goalX - RobotX ) + (goalY - RobotY) * (goalY - RobotY));
		sprintf(txt, "Distance to goal: %f\n", distanceToGoal);
		WDS(txt);
		sprintf(txt, "pose: %f, %f\n", RobotX, RobotY);
		WDS(txt);

		if (distanceToGoal < 100.0)
		{
			there = true;
			break;
		}
		long nowTime = time1[T1];
		float dt = (nowTime - lastTime) / 1000.0;
		int p = (int)GetPidTurnPower(initialH, dt);
		motor[M2] = 30 + p;
		motor[M1] = 30;
		lastTime = nowTime;
		wait1Msec(1000/20);
	}
	motor[M1] = 0;
	motor[M2] = 0;
	WaitMotorsIdle();
}

task main()
{
	clearDebugStream();
	WDS("xbee.c\n");

	//nSyncedMotors = synchAC; //frankly, worthless in v4.27

	nMotorPIDSpeedCtrl[M1] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[M2] = mtrSpeedReg;

	time1[T1] = 0;

	nxtEnableHSPort();            //Enable High Speed Port #4
	nxtSetHSBaudRate(57600);
	nxtHS_Mode = hsRawMode;       //Set to Raw Mode (vs. Master/Slave Mode)

	MSIMUsetGyroFilter(MSIMU, MSIMU_GYRO_FILTER_LEVEL_4); // filtering
	wait1Msec(100);		// allow time for reconfigure

	string sub = "SUBpc/#\n";
	nxtWriteRawHS(sub, strlen(sub), 0);

	lastPoseTick = time1[T1];
	startTask(BgUpdateTask);
	//startTask(debugPrint);

	// make a move
	PidMove(2000.0);	// in mm I hope :P

	//PidRotate(ToRadians(180));

	//PidMove(2000.0);

	//PidRotate(ToRadians(180));

	WDS("Done\n");
	wait1Msec(100);
	stopAllTasks();
}
