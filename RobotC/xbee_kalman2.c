#pragma config(Sensor, S1,     Bumper1,	sensorTouch)
#pragma config(Sensor, S3,     MSIMU,   sensorI2CCustomFastSkipStates)
#pragma config(Sensor, S4,     XBee,    sensorHighSpeed)
#pragma config(Motor,  motorA, M1,      tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC, M2,      tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")

#include "drivers/mindsensors-imu.h"

/* notes
57600
xbee on PC source addr 4 dest 3
xbee on nxt source 3 dest 4

1 touch
2 Mindsensor Absolute IMU
4 xbee (485)

A M1 driveRight
C M2 driveLeft

*/

#include "misc.h"

#define MoveCompleteThreshold 50.0
#define PoseUpdateRate 20
#define MoveUpdateRate 50

#define BasePower 30.0

float WheelBase = 120.0;
float WheelDiameter = 80.0;
int TicksPerRevolution = 360;
float ticksToMM;		// calculated, this is what we need.

long CurrentLeftTacho = 0;
long CurrentRightTacho = 0;
long LastLeftTacho = 0;
long LastRightTacho = 0;

float RobotX = 0;
float RobotY = 0;
float RobotH = 0;		// heading degrees!!!

int hsInBuffIdx = 0;
ubyte hsInBuff[128];
char json[128];	// (not thread safe!)

float GetGyroRateZ()
{
	//Sensitivity Level Reading Units
	//250 degrees/sec 8.75 milli-degrees/second
	//500 degrees/second 17.5 milli-degrees/second
	//2000 degrees/second 70 milli-degrees/second

	int x, y, z;
	MSIMUreadGyroAxes(MSIMU, x, y, z);
	return z * 8.75 / 1000.0;
}

float meanGyroZValue(int interval, int N)
{
	float som = 0;
	for(int i = 0; i < N; i++)
	{
		som += GetGyroRateZ();
		wait1Msec(interval);
	}
	return som / N;
}


void WaitMotorsIdle()
{
	while (nMotorRunState[M1] != runStateIdle &&
		nMotorRunState[M1] != runStateIdle)
	wait1Msec(20);
}

//---  incoming subscriptions  -------------------------

task CheckMQTT()
{
	while (true)
	{
		while (nxtGetAvailHSBytes() > 0)
		{
			nxtReadRawHS(&hsInBuff[hsInBuffIdx], 1);
			if (hsInBuff[hsInBuffIdx] == '\n')
			{
				_T("MQTT msg recvd: {0}\n", hsInBuff);
				// +++ process
				hsInBuffIdx = 0;
				continue;
			}
			hsInBuffIdx++;
			releaseCPU();
		}
		wait1Msec(1000/10);
	}
}

//---  Pose / Kalman  -------------------------

float GyroOffset,
varianceTacho = 0.9,
varianceGyro = 0.119,
varianceFilterPredicted,
varianceFilterUpdated,
kalmanGain,
tachoMeasured,
tachoPredicted,
tachoUpdated,
gyroMeasured;

long LastPoseTime = time1[T1];

void CalcPoseWithGyro()
{
	float a = 5 / 0;	// not implemented

	// milli-degree/second is what the gyro uses
	// time1 uses milliseconds
	long nowTime = time1[T1];
	// milli-degree/second is what the gyro reports
	float dt = (nowTime - LastPoseTime) / 1000.0;

	CurrentLeftTacho = nMotorEncoder[M2];
	CurrentRightTacho = nMotorEncoder[M1];

	long leftTachoChange = CurrentLeftTacho - LastLeftTacho;
	long rightTachoChange = CurrentRightTacho - LastRightTacho;

	if (abs(leftTachoChange) + abs(rightTachoChange) < 1)
		return; // insignificant movement, avoid updating

	float delta = (leftTachoChange + rightTachoChange) * ticksToMM / 2.0;
	tachoMeasured = (leftTachoChange - rightTachoChange) *
	ticksToMM / WheelBase;
	gyroMeasured = meanGyroZValue(5,4) - GyroOffset;

	// predict
	tachoPredicted = tachoUpdated + dt * gyroMeasured;
	varianceFilterPredicted = varianceFilterUpdated + varianceGyro;

	// heading must be between 0 and 2*PI
	tachoPredicted = NormalizeAngle(tachoPredicted);

	// Kalman gain
	kalmanGain = varianceFilterPredicted /
	(varianceFilterPredicted + varianceTacho);

	// update
	tachoUpdated = tachoPredicted + kalmanGain * (tachoMeasured - tachoPredicted);
	varianceFilterUpdated = varianceFilterPredicted +
	kalmanGain * (varianceTacho - varianceFilterPredicted);

	RobotH = NormalizeHeading(tachoUpdated);

	RobotX += delta * sin(RobotH);
	RobotY += delta * -cos(RobotH);

	LastLeftTacho = CurrentLeftTacho;
	LastRightTacho = CurrentRightTacho;
	LastPoseTime = nowTime;

	sprintf(json, "PUBnxt/Pose{\"x\":%f,\"y\":%f,\"h\":%f}\n",
	RobotX, RobotY, RobotH);
	//_T(json);
	nxtWriteRawHS(json, strlen(json), 0);
}

void CalcPose()
{
	long nowTime = time1[T1];

	float dt = (nowTime - LastPoseTime) / 1000.0;

	CurrentLeftTacho = nMotorEncoder[M2];
	CurrentRightTacho = nMotorEncoder[M1];

	long leftTachoChange = CurrentLeftTacho - LastLeftTacho;
	long rightTachoChange = CurrentRightTacho - LastRightTacho;

	if (abs(leftTachoChange) + abs(rightTachoChange) < 1)
		return; // insignificant movement, avoid updating

	float delta = (leftTachoChange + rightTachoChange) * ticksToMM / 2.0;
		tachoMeasured = (leftTachoChange - rightTachoChange) *
	ticksToMM / WheelBase;

	RobotX += delta * -sin(RobotH + (tachoMeasured / 2.0));
	RobotY += delta * cos(RobotH + (tachoMeasured / 2.0));
	RobotH += ToDegrees(tachoMeasured);
	RobotH = NormalizeHeading(RobotH);

	LastLeftTacho = CurrentLeftTacho;
	LastRightTacho = CurrentRightTacho;
	LastPoseTime = nowTime;

	sprintf(json, "PUBPilot/Pose{\"X\":%f,\"Y\":%f,\"H\":%f}\r\n", RobotX, RobotY, RobotH);
	//_T(json);
	nxtWriteRawHS(json, strlen(json), 0);
}

task UpdatePose()
{
	while (true)
	{
		//CalcPoseWithGyro();
		CalcPose();
		wait1Msec(1000 / PoseUpdateRate); // times per second to update
	}
}

//--- PID -------------------

#define K1_P 2.0
#define K1_I 0.0
#define K1_D 0.1

float pid1PreviousError = 0;
float pid1Integral, pid1Derivative;	// global so we can debug

float Pid1(float sp, float pv, float dt)
{
	float p = 0;
	if (dt > 0)
	{
		float error = sp - pv;
		pid1Integral = pid1Integral + error * dt;
		pid1Derivative = (error - pid1PreviousError) / dt;
		p = K1_P * error + K1_I * pid1Integral + K1_D * pid1Derivative;
		p = p > 100 ? 100 : p < -100 ? -100 : p;
		pid1PreviousError = error;
	}
	return p;
}

void Rotate(float angle)
{
	//	+++ we need to pick base on left or right
	//	but -100 is always turn in place, motor power needs to be influenced by direction
	//	nSyncedTurnRatio = -100;	// rotate in place

	//	char txt[128];
	//	long lastTime = time1[T1];
	//	nSyncedTurnRatio = -100;	// rotate in place
	//	angle = NormalizeAngle(RobotH + angle);
	//	sprintf(txt, "Pid Rotate sp(%f) pv(%f)\n", ToDegrees(angle), ToDegrees(RobotH));
	//	_T(txt);
	//	while (abs(pidPreviousError) > ToRadians(2))
	//	{
	//		long timeNow = time1[T1];
	//		float dt = (timeNow - lastTime) / 1000.0;
	//		float p = GetPidTurnPower(angle, dt);
	//		motor[M1] = (int)p;
	//		lastTime = timeNow;
	//		sprintf(txt, "PidRot sp(%f) pv(%f) error(%f) dt(%f) pwr(%f)\n",
	//		ToDegrees(angle), ToDegrees(RobotH), pidPreviousError, dt, p);
	//		_T(txt);
	//		wait1Msec(20);
	//	}
	//	motor[M1] = 0;
	//	WaitMotorsIdle();
	//	sprintf(txt, "Rotate complete sp(%f) pv(%f)\n", ToDegrees(angle), ToDegrees(RobotH));
	//	_T(txt);
}

void Move(float x, float y)
{
	long lastTime = time1[T1];
	sprintf(dtxt, "--Move: %f, %f", x, y);

	while (true)
	{
		float distanceToGoal = Distance(x, y, RobotX, RobotY);

		// threshold needs to be reasonable given update rate
		if (distanceToGoal < MoveCompleteThreshold)
			break;

		float headingToGoal = atan2( (x-RobotX),(y-RobotY)) * 180.0 / PI;

		long nowTime = time1[T1];
		float dt = (nowTime - lastTime) / 1000.0;

		int p = (int)Pid1(headingToGoal, RobotH, dt);
		motor[M2] = BasePower + p;
		motor[M1] = BasePower;

		lastTime = nowTime;

		sprintf(dtxt, "goal: %f, %f, bearing %f\n", x, y, headingToGoal); _T(dtxt);
		sprintf(dtxt, "Distance to goal: %f\n", distanceToGoal); _T(dtxt);
		sprintf(dtxt, "pose: %f, %f, %f\n", RobotX, RobotY, RobotH); _T(dtxt);

		// update N times per sec
		wait1Msec(1000/2);
	}

	motor[M1] = 0;
	motor[M2] = 0;
	WaitMotorsIdle();
}

void Move(float d)
{
	float goalX = RobotX + d * -sin(ToRadians(RobotH));
	float goalY = RobotY + d * cos(ToRadians(RobotH));
	Move (goalX, goalY);
	WaitMotorsIdle();
}

//--- main -------------------------

task main()
{
	clearDebugStream();
	_T("xbee_kalman1.c\n");

	// geometry
	ticksToMM = PI * WheelDiameter / TicksPerRevolution;

	//nSyncedMotors = synchAC; //frankly, worthless in v4.27
	nMotorPIDSpeedCtrl[M1] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[M2] = mtrSpeedReg;

	// connection to MQTT Bridge
	nxtEnableHSPort();
	nxtSetHSBaudRate(57600);
	nxtHS_Mode = hsRawMode;

	// subscribe isnt really being used ATM, but it shows up on
	// the bridge console indicating the connection is good
	string sub = "SUBpc/#\n";
	nxtWriteRawHS(sub, strlen(sub), 0);

	MSIMUsetGyroFilter(MSIMU, MSIMU_GYRO_FILTER_LEVEL_4); // filtering
	wait1Msec(250);		// allow time for reconfigure

	GyroOffset = meanGyroZValue(5,100);
	_T("GyroOffset %f\n", GyroOffset);

	// initialise the kalman filter;
	tachoUpdated = GetGyroRateZ();
	varianceFilterUpdated = 0;

	time1[T1] = 0;			// resest the clock
	//startTask(CheckMQTT);
	startTask(UpdatePose);

	Move(200);
	//Rotate(ToRadians(180));

	//testing
	//while (true)
	//	wait1Msec(100);

	_T("Done\n");
	wait1Msec(100);
	stopAllTasks();
}
