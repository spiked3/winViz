#pragma config(Sensor, S1,     Bumper1,	sensorTouch)
#pragma config(Sensor, S3,     MSIMU,   sensorI2CCustomFastSkipStates)
#pragma config(Sensor, S4,     XBee,    sensorHighSpeed)
#pragma config(Motor,  motorA, M1,      tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorC, M2,      tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma DebuggerWindows("debugStream")

#include "drivers/mindsensors-imu.h"

/* notes
57600
xbee on PC source addr 4 dest 3
xbee on nxt source 3 dest 4

1 touch
2 Mindsensor Absolute IMU
4 xbee (485)

A M1 driveRight
C M2 driveLeft

*/

#define WDS writeDebugStream

#define MoveCompleteThreshold 50.0
#define PoseUpdateRate 50
#define MoveUpdateRate 50

#define BasePower 30.0

#define K_P 80.0
#define K_I 0.0
#define K_D 5.0

float PI2 = 2.0 * PI;

float WheelBase = 120.0;
float WheelDiameter = 80.0;
int TicksPerRevolution = 360;
float ticksToMM;		// calculated, this is what we need.

long CurrentLeftTacho = 0;
long CurrentRightTacho = 0;
long LastLeftTacho = 0;
long LastRightTacho = 0;

float RobotX = 0;
float RobotY = 0;
float RobotH = 0;

int hsInBuffIdx = 0;
ubyte hsInBuff[128];
char json[64];	// (not thread safe!)

//---  Util  -------------------------

float NormalizeAngle(float angle)
{
	while (angle > PI2)
		angle -= PI2;
	while (angle < -PI2)
		angle += PI2;
	return angle;
}

float GetGyroRateZ()
{
	//Sensitivity Level Reading Units
	//250 degrees/sec 8.75 milli-degrees/second
	//500 degrees/second 17.5 milli-degrees/second
	//2000 degrees/second 70 milli-degrees/second

	int x, y, z;
	MSIMUreadGyroAxes(MSIMU, x, y, z);
	return z * 8.75 / 1000.0;
}

float meanGyroZValue(int interval, int N)
{
	float som = 0;
	for(int i = 0; i < N; i++)
	{
		som += GetGyroRateZ();
		wait1Msec(interval);
	}
	return som / N;
}

float ToDegrees(float a)
{
	return a * 180 / PI;
}

float ToRadians(float a)
{
	return a * PI / 180.0;
}

void WaitMotorsIdle()
{
	while (nMotorRunState[M1] != runStateIdle &&
		nMotorRunState[M1] != runStateIdle)
	wait1Msec(20);
}

float Distance(float x1, float y1, float x2, float y2)
{
	return sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));
}

//---  incoming subscriptions  -------------------------

task CheckMQTT()
{
	while (true)
	{
		while (nxtGetAvailHSBytes() > 0)
		{
			nxtReadRawHS(&hsInBuff[hsInBuffIdx], 1);
			if (hsInBuff[hsInBuffIdx] == '\n')
			{
				WDS("MQTT msg recvd: {0}\n", hsInBuff);
				// +++ process
				hsInBuffIdx = 0;
				continue;
			}
			hsInBuffIdx++;
			releaseCPU();
		}
		wait1Msec(1000/10);
	}
}

//---  Pose / Kalman  -------------------------

float GyroOffset,
varianceTacho = 0.9,
varianceGyro = 0.119,
varianceFilterPredicted,
varianceFilterUpdated,
kalmanGain,
tachoMeasured,
tachoPredicted,
tachoUpdated,
gyroMeasured;

long LastPoseTime = time1[T1];

void CalcPoseWithGyro()
{
	// milli-degree/second is what the gyro uses
	// time1 uses milliseconds
	long nowTime = time1[T1];
	// milli-degree/second is what the gyro reports
	float dt = (nowTime - LastPoseTime) / 1000.0;

	CurrentLeftTacho = nMotorEncoder[M2];
	CurrentRightTacho = nMotorEncoder[M1];

	long leftTachoChange = CurrentLeftTacho - LastLeftTacho;
	long rightTachoChange = CurrentRightTacho - LastRightTacho;

	if (abs(leftTachoChange) + abs(rightTachoChange) < 1)
		return; // insignificant movement, avoid updating

	float delta = (leftTachoChange + rightTachoChange) * ticksToMM / 2.0;
	tachoMeasured = (leftTachoChange - rightTachoChange) *
	ticksToMM / WheelBase;
	gyroMeasured = meanGyroZValue(5,4) - GyroOffset;

	// predict
	tachoPredicted = tachoUpdated + dt * gyroMeasured;
	varianceFilterPredicted = varianceFilterUpdated + varianceGyro;

	// heading must be between 0 and 2*PI
	tachoPredicted = NormalizeAngle(tachoPredicted);

	// Kalman gain
	kalmanGain = varianceFilterPredicted /
	(varianceFilterPredicted + varianceTacho);

	// update
	tachoUpdated = tachoPredicted + kalmanGain * (tachoMeasured - tachoPredicted);
	varianceFilterUpdated = varianceFilterPredicted +
	kalmanGain * (varianceTacho - varianceFilterPredicted);

	RobotH = NormalizeAngle(tachoUpdated);

	RobotX += delta * sin(RobotH);
	RobotY += delta * -cos(RobotH);

	LastLeftTacho = CurrentLeftTacho;
	LastRightTacho = CurrentRightTacho;
	LastPoseTime = nowTime;

	sprintf(json, "PUBnxt/Pose,{\"x\":%f,\"y\":%f,\"h\":%f}\n",
	RobotX, RobotY, RobotH);
	//WDS(json);
	nxtWriteRawHS(json, strlen(json), 0);
}

void CalcPose()
{
	long nowTime = time1[T1];
	// for velocity (not used ATM)
	float dt = (nowTime - LastPoseTime) / 1000.0;

	CurrentLeftTacho = nMotorEncoder[M2];
	CurrentRightTacho = nMotorEncoder[M1];

	long leftTachoChange = CurrentLeftTacho - LastLeftTacho;
	long rightTachoChange = CurrentRightTacho - LastRightTacho;

	if (abs(leftTachoChange) + abs(rightTachoChange) < 1)
		return; // insignificant movement, avoid updating

	float delta = (leftTachoChange + rightTachoChange) * ticksToMM / 2.0;
	tachoMeasured = (leftTachoChange - rightTachoChange) *
	ticksToMM / WheelBase;

	RobotX += delta * sin(RobotH + (tachoMeasured / 2.0));
	RobotY += delta * -cos(RobotH + (tachoMeasured / 2.0));
	RobotH += tachoMeasured;

	LastLeftTacho = CurrentLeftTacho;
	LastRightTacho = CurrentRightTacho;
	LastPoseTime = nowTime;

	sprintf(json, "PUBnxt/Pose,{\"x\":%f,\"y\":%f,\"h\":%f}\n",
	RobotX, RobotY, RobotH);
	//WDS(txt);
	nxtWriteRawHS(json, strlen(json), 0);
}

task UpdatePose()
{
	while (true)
	{
		//CalcPoseWithGyro();
		CalcPose();
		wait1Msec(1000 / PoseUpdateRate); // times per second to update
	}
}

//--- PID -------------------

float pidPreviousError = 0;
float pidIntegral, derivative;	// global so we can debug

float GetPidTurnPower(float sp, float dt)
{
	float error = sp - RobotH;
	pidIntegral = pidIntegral + error * dt;
	derivative = (error - pidPreviousError) / dt;
	float p = K_P * error + K_I * pidIntegral + K_D * derivative;
	p = p > 100 ? 100 : p < -100 ? -100 : p;
	pidPreviousError = error;
	return p;
}

void Rotate(float angle)
{
	//	+++ we need to pick base on left or right
	//	but -100 is always turn in place, motor power needs to be influenced by direction
	//	nSyncedTurnRatio = -100;	// rotate in place

	//	char txt[128];
	//	long lastTime = time1[T1];
	//	nSyncedTurnRatio = -100;	// rotate in place
	//	angle = NormalizeAngle(RobotH + angle);
	//	sprintf(txt, "Pid Rotate sp(%f) pv(%f)\n", ToDegrees(angle), ToDegrees(RobotH));
	//	WDS(txt);
	//	while (abs(pidPreviousError) > ToRadians(2))
	//	{
	//		long timeNow = time1[T1];
	//		float dt = (timeNow - lastTime) / 1000.0;
	//		float p = GetPidTurnPower(angle, dt);
	//		motor[M1] = (int)p;
	//		lastTime = timeNow;
	//		sprintf(txt, "PidRot sp(%f) pv(%f) error(%f) dt(%f) pwr(%f)\n",
	//		ToDegrees(angle), ToDegrees(RobotH), pidPreviousError, dt, p);
	//		WDS(txt);
	//		wait1Msec(20);
	//	}
	//	motor[M1] = 0;
	//	WaitMotorsIdle();
	//	sprintf(txt, "Rotate complete sp(%f) pv(%f)\n", ToDegrees(angle), ToDegrees(RobotH));
	//	WDS(txt);
}

void Move(float x, float y)
{
	long lastTime = time1[T1];

	//sprintf(txt, "goal: %f, %f\n", goalX, goalY);
	//WDS(txt);

	if (Distance(x, y, RobotX, RobotY) > MoveCompleteThreshold)
	{
		while (true)
		{
			float distanceToGoal = Distance(x, y, RobotX, RobotY);
			float desiredH = atan2((y - RobotY),(x - RobotX)) + PI/2;
			//WDS(txt, "Distance to goal: %f\n", distanceToGoal);
			//WDS(txt, "pose: %f, %f\n", RobotX, RobotY);
			WDS("Desired hdg to goal: %f\n", desiredH);

			// threshold needs to be reasonable given update rate
			// 120 is same as wheelbase
			if (distanceToGoal < MoveCompleteThreshold)
				break;
			long nowTime = time1[T1];
			float dt = (nowTime - lastTime) / 1000.0;
			int p = (int)GetPidTurnPower(desiredH, dt);
			motor[M2] = BasePower + p;
			motor[M1] = BasePower;
			lastTime = nowTime;
			// update N times per sec
			wait1Msec(1000 / MoveUpdateRate);
		}
	}

	motor[M1] = 0;
	motor[M2] = 0;
	WaitMotorsIdle();
}

void Move(float d)
{
	float basePower = 30.0;
	float initialH = RobotH;
	long lastTime = time1[T1];

	// where we are going
	float goalX = RobotX + d * -sin(RobotH);	// you really have to watch out, robot vs view x/y
	float goalY = RobotY - d * cos(RobotH);

	//WDS(txt, "goal: %f, %f\n", goalX, goalY);

	float distanceToGoal = Distance(goalX, goalY, RobotX, RobotY);
	//WDS("Distance to goal: %f\n", distanceToGoal);
	if (distanceToGoal > MoveCompleteThreshold)
	{
		while (true)
		{
			distanceToGoal = Distance(goalX, goalY, RobotX, RobotY);
			//WDS("Distance to goal: %f\n", distanceToGoal);
			//WDS(txt, "pose: %f, %f\n", RobotX, RobotY);

			// threshold needs to be reasonable given update rate
			// 120 is same as wheelbase
			if (distanceToGoal < MoveCompleteThreshold)
				break;
			long nowTime = time1[T1];
			float dt = (nowTime - lastTime) / 1000.0;
			int p = (int)GetPidTurnPower(initialH, dt);
			motor[M2] = BasePower + p;
			motor[M1] = BasePower;
			lastTime = nowTime;
			// update N times per sec
			wait1Msec(1000/30);
		}
	}

	motor[M1] = 0;
	motor[M2] = 0;
	WaitMotorsIdle();
}

//--- main -------------------------

task main()
{
	clearDebugStream();
	WDS("xbee_kalman1.c\n");

	// geometry
	ticksToMM = PI * WheelDiameter / TicksPerRevolution;

	//nSyncedMotors = synchAC; //frankly, worthless in v4.27
	nMotorPIDSpeedCtrl[M1] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[M2] = mtrSpeedReg;

	// connection to MQTT Bridge
	nxtEnableHSPort();
	nxtSetHSBaudRate(57600);
	nxtHS_Mode = hsRawMode;

	// subscribe isnt really being used ATM, but it shows up on
	// the bridge console indicating the connection is good
	string sub = "SUBpc/#\n";
	nxtWriteRawHS(sub, strlen(sub), 0);

	MSIMUsetGyroFilter(MSIMU, MSIMU_GYRO_FILTER_LEVEL_4); // filtering
	wait1Msec(250);		// allow time for reconfigure

	GyroOffset = meanGyroZValue(5,100);
	WDS("GyroOffset %f\n", GyroOffset);

	// initialise the kalman filter;
	tachoUpdated = GetGyroRateZ();
	varianceFilterUpdated = 0;

	time1[T1] = 0;			// resest the clock
	startTask(CheckMQTT);
	startTask(UpdatePose);

	// make a move
	//Move(1000.0);		// in mm
	Move(1000, 0);			// x,y
	Move(0, 0);			// x,y
	//Rotate(ToRadians(180));

	//testing
	//while (true)
	//	wait1Msec(100);

	WDS("Done\n");
	wait1Msec(100);
	stopAllTasks();
}
